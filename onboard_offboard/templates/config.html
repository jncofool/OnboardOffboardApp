{% extends "base.html" %}
{% block title %}Configuration · Onboard &amp; Offboard{% endblock %}
{% block content %}
  <h1>Directory Configuration</h1>
  <p>Update the connection details, sync command, and reusable job role templates used by the portal.</p>

  <form method="post">
    <section>
      <h2>Active Directory</h2>
      <div class="field">
        <label for="server_uri">Server URI</label>
        <input id="server_uri" name="server_uri" type="text" value="{{ config.ldap.server_uri }}" required />
      </div>
      <div class="field">
        <label for="user_dn">Bind User DN</label>
        <input id="user_dn" name="user_dn" type="text" value="{{ config.ldap.user_dn }}" required />
      </div>
      <div class="field">
        <label for="password">Password</label>
        <input id="password" name="password" type="password" value="{{ config.ldap.password }}" required />
      </div>
      <div class="field">
        <label for="base_dn">Base DN</label>
        <input id="base_dn" name="base_dn" type="text" value="{{ config.ldap.base_dn }}" required />
      </div>
      <div class="field">
        <label for="user_ou">Default User OU</label>
        <input id="user_ou" name="user_ou" type="text" value="{{ config.ldap.user_ou }}" required />
      </div>
      <div class="field">
        <label><input type="checkbox" name="use_ssl" {% if config.ldap.use_ssl %}checked{% endif %} /> Use SSL</label>
      </div>
      <div class="field">
        <label for="manager_search_filter">Manager Search Filter</label>
        <input id="manager_search_filter" name="manager_search_filter" type="text" value="{{ config.ldap.manager_search_filter }}" />
      </div>
      <div class="field">
        <label for="manager_attributes">Manager Attributes (comma separated)</label>
        <input id="manager_attributes" name="manager_attributes" type="text" value="{{ config.ldap.manager_attributes | join(', ') }}" />
      </div>
      <div class="field">
        <label for="group_search_base">Group Search Base (optional)</label>
        <input id="group_search_base" name="group_search_base" type="text" value="{{ config.ldap.group_search_base or '' }}" placeholder="OU=User Groups,DC=example,DC=com" />
      </div>
      <div class="field">
        <label for="mock_data_file">Mock Directory File (optional)</label>
        <input id="mock_data_file" name="mock_data_file" type="text" value="{{ config.ldap.mock_data_file or '' }}" />
      </div>
    </section>

    <section>
      <h2>Sync Command</h2>
      <div class="field">
        <label for="sync_command">Command</label>
        <input id="sync_command" name="sync_command" type="text" value="{{ config.sync.command }}" placeholder="Start-ADSyncSyncCycle -PolicyType Delta" />
      </div>
      <div class="field">
        <label><input type="checkbox" name="sync_shell" {% if config.sync.shell %}checked{% endif %} /> Run command in shell</label>
      </div>
      <div class="field">
        <label for="sync_timeout">Timeout (seconds)</label>
        <input id="sync_timeout" name="sync_timeout" type="number" min="0" value="{{ config.sync.timeout }}" />
      </div>
    </section>

    <section>
      <h2>Storage</h2>
      <div class="field">
        <label for="job_roles_file">Job Roles File</label>
        <input id="job_roles_file" name="job_roles_file" type="text" value="{{ config.storage.job_roles_file }}" />
      </div>
      <div class="field">
        <label for="license_jobs_file">License Jobs File</label>
        <input
          id="license_jobs_file"
          name="license_jobs_file"
          type="text"
          value="{{ config.storage.license_jobs_file }}"
          placeholder="data/license_jobs.json"
        />
        <div class="hint">Queued Microsoft 365 license assignments are stored here.</div>
      </div>
    </section>

    <section>
      <h2>Microsoft 365</h2>
      <p>
        Provide your Microsoft Graph application credentials to manage cloud licenses after onboarding.
        Leave the client secret blank to keep the existing value.
      </p>
      <div class="field-grid">
        <div class="field">
          <label for="m365_tenant_id">Tenant ID</label>
          <input
            id="m365_tenant_id"
            name="m365_tenant_id"
            type="text"
            value="{{ config.m365.tenant_id or '' }}"
            placeholder="7c98eced-e44f-40c3-b38b-242eeaebde35"
            autocomplete="off"
          />
        </div>
        <div class="field">
          <label for="m365_client_id">Client ID (Application ID)</label>
          <input
            id="m365_client_id"
            name="m365_client_id"
            type="text"
            value="{{ config.m365.client_id or '' }}"
            placeholder="33a87ac0-5965-4a22-9f5b-e45dd48d5211"
            autocomplete="off"
          />
        </div>
        <div class="field">
          <label for="m365_client_secret">Client Secret</label>
          <input
            id="m365_client_secret"
            name="m365_client_secret"
            type="password"
            value=""
            placeholder="{% if m365_status.has_secret %}Leave blank to keep existing secret{% else %}Paste generated secret{% endif %}"
            autocomplete="off"
          />
        </div>
        <div class="field">
          <label for="m365_sku_cache_file">License Cache File</label>
          <input
            id="m365_sku_cache_file"
            name="m365_sku_cache_file"
            type="text"
            value="{{ config.m365.sku_cache_file }}"
          />
        </div>
        <div class="field">
          <label for="m365_cache_ttl_minutes">Cache TTL (minutes)</label>
          <input
            id="m365_cache_ttl_minutes"
            name="m365_cache_ttl_minutes"
            type="number"
            min="1"
            value="{{ config.m365.cache_ttl_minutes }}"
          />
        </div>
      </div>
      <div class="status-card" id="m365_status_card">
        <span class="badge{% if m365_status.configured and not m365_status.error and not m365_status.stale %} ok{% elif m365_status.stale or m365_status.error %} stale{% endif %}" id="m365_status_badge">
          {% if not m365_status.configured %}Not Configured{% elif m365_status.error %}Error{% elif m365_status.stale %}Stale{% else %}Ready{% endif %}
        </span>
        <p id="m365_status_message">{{ m365_status.message }}</p>
        <p id="m365_status_error" class="error" {% if not m365_status.error %}style="display: none;"{% endif %}>{{ m365_status.error }}</p>
        <ul class="status-meta">
          <li><strong>SKUs cached:</strong> <span id="m365_status_count">{{ m365_status.sku_count }}</span></li>
          <li><strong>Last refreshed:</strong> <span id="m365_status_fetched">{{ m365_status.fetched_at or 'Never' }}</span></li>
          <li><strong>Cache TTL:</strong> {{ m365_status.cache_ttl_minutes }} minutes</li>
        </ul>
        <button type="button" id="m365_refresh_button" {% if not m365_status.configured %}disabled{% endif %}>
          Refresh License Catalog
        </button>
        <small>Cache file: <span id="m365_status_cache_path">{{ m365_status.cache_path }}</span></small>
      </div>
    </section>

    <div class="field">
      <button type="submit">Save Configuration</button>
    </div>
  </form>

  <section id="role_management">
    <h2>Job Roles &amp; Groups</h2>
    <p>
      Manage reusable job role templates. Defaults set here appear during onboarding and cloning, but you can still add or remove groups per user.
    </p>
    <table>
      <thead>
        <tr>
          <th style="width: 20%;">Name</th>
          <th style="width: 25%;">Default Manager</th>
          <th style="width: 15%;">Groups</th>
          <th>Notes</th>
          <th style="width: 15%;">Actions</th>
        </tr>
      </thead>
      <tbody id="role_table_body">
        <tr>
          <td colspan="5">Loading roles…</td>
        </tr>
      </tbody>
    </table>
    <div class="field" style="margin-top: 1rem;">
      <button type="button" id="role_new_button">Create Role</button>
    </div>

    <form id="role_form" class="card" autocomplete="off">
      <h3 id="role_form_heading">Add Role</h3>
      <input type="hidden" id="role_original_name" />
        <div class="field">
          <label for="role_name">Role Name</label>
          <input
            id="role_name"
            type="text"
            list="role-title-suggestions"
            placeholder="Start typing a job title"
            autocomplete="off"
            required
          />
          <datalist id="role-title-suggestions">
            {% for title in job_titles %}
              <option value="{{ title }}"></option>
            {% endfor %}
          </datalist>
          <div class="hint">
            Suggestions combine existing templates and Active Directory job titles. You can still enter a new title.
          </div>
        </div>
      <div class="field">
        <label for="role_description">Description (optional)</label>
        <input id="role_description" type="text" />
      </div>
      <div class="field">
        <label for="role_user_ou">Default User OU</label>
        <input id="role_user_ou" type="text" list="role-ou-suggestions" placeholder="Leave blank to use global default" />
        <datalist id="role-ou-suggestions"></datalist>
      </div>
      <div class="field">
        <label for="role_manager_search">Default Manager (optional)</label>
        <div class="autocomplete">
          <input
            id="role_manager_search"
            type="text"
            placeholder="Search by name, username, or email"
            autocomplete="off"
          />
          <input id="role_manager_dn" type="hidden" />
          <div class="autocomplete-results" id="role_manager_results" hidden></div>
        </div>
        <button type="button" class="inline-button" id="role_manager_clear">Clear</button>
      </div>
      <div class="field">
        <label for="role_attributes">Attributes (key=value per line, optional)</label>
        <textarea id="role_attributes" placeholder="title=Field Service Technician"></textarea>
      </div>
      <div class="field">
        <label for="role_group_search">Default Groups</label>
        <div id="role_group_tags" class="tag-list" hidden></div>
        <div class="autocomplete">
          <input
            id="role_group_search"
            type="text"
            placeholder="Search for groups"
            autocomplete="off"
          />
          <div class="autocomplete-results" id="role_group_results" hidden></div>
        </div>
        <div class="hint">Search to add groups. Click the × on a tag to remove it.</div>
      </div>
      <div class="field" id="role_form_message" hidden></div>
      <div class="field">
        <button type="submit">Save Role</button>
        <button type="button" class="inline-button" id="role_reset_button">Reset</button>
      </div>
    </form>
  </section>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
        const initialRoles = {{ roles_json|tojson }};
        const initialJobTitles = {{ job_titles|tojson }};
        const state = {
          roles: Array.isArray(initialRoles) ? [...initialRoles] : [],
        };

      const fetchJson = async (endpoint, query, limit = 200) => {
        const url = new URL(endpoint, window.location.origin);
        if (query) {
          url.searchParams.set("q", query);
        }
        if (limit) {
          url.searchParams.set("limit", limit);
        }
        const response = await fetch(url.toString(), {
          headers: { Accept: "application/json" },
        });
        if (!response.ok) {
          throw new Error(`Directory lookup failed (${response.status})`);
        }
        return response.json();
      };

      const m365InitialStatus = {{ m365_status|tojson }};
      const m365Card = document.getElementById("m365_status_card");
      const m365Message = document.getElementById("m365_status_message");
      const m365Error = document.getElementById("m365_status_error");
      const m365Count = document.getElementById("m365_status_count");
      const m365Fetched = document.getElementById("m365_status_fetched");
      const m365RefreshButton = document.getElementById("m365_refresh_button");
      const m365CachePath = document.getElementById("m365_status_cache_path");
      const m365Badge = document.getElementById("m365_status_badge");
      const m365RefreshLabel = m365RefreshButton ? m365RefreshButton.textContent : "";
      let currentM365Status = m365InitialStatus;

      const renderM365Status = (data) => {
        if (!m365Card) {
          return;
        }
        const status = data || {};
        if (m365Message) {
          m365Message.textContent =
            status.message || "Microsoft 365 integration is not configured.";
        }
        if (m365Error) {
          if (status.error) {
            m365Error.textContent = status.error;
            m365Error.style.display = "";
          } else {
            m365Error.textContent = "";
            m365Error.style.display = "none";
          }
        }
        if (m365Count) {
          m365Count.textContent =
            typeof status.sku_count === "number" ? status.sku_count : 0;
        }
        if (m365Fetched) {
          m365Fetched.textContent = status.fetched_at
            ? new Date(status.fetched_at).toLocaleString()
            : "Never";
        }
        if (m365CachePath) {
          m365CachePath.textContent = status.cache_path || "";
        }
        if (m365RefreshButton) {
          m365RefreshButton.disabled = !status.configured;
        }
        if (m365Badge) {
          m365Badge.classList.remove("ok", "stale");
          if (!status.configured) {
            m365Badge.textContent = "Not Configured";
          } else if (status.error) {
            m365Badge.classList.add("stale");
            m365Badge.textContent = "Error";
          } else if (status.stale) {
            m365Badge.classList.add("stale");
            m365Badge.textContent = "Stale";
          } else {
            m365Badge.classList.add("ok");
            m365Badge.textContent = "Ready";
          }
        }
        currentM365Status = status;
      };

      const loadM365Status = async (refresh = false) => {
        if (!m365Card) {
          return;
        }
        const endpoint = refresh ? "/api/m365/skus/refresh" : "/api/m365/skus";
        const options =
          refresh
            ? { method: "POST", headers: { Accept: "application/json" } }
            : { headers: { Accept: "application/json" } };
        try {
          const response = await fetch(endpoint, options);
          const payload = await response.json();
          if (!response.ok) {
            throw new Error(payload.message || "Unable to query Microsoft 365.");
          }
          renderM365Status(payload);
        } catch (error) {
          if (m365Message) {
            m365Message.textContent =
              error instanceof Error ? error.message : String(error);
          }
          if (m365Error) {
            m365Error.textContent = "";
            m365Error.style.display = "none";
          }
        } finally {
          if (m365RefreshButton) {
            m365RefreshButton.disabled = !currentM365Status.configured;
            m365RefreshButton.textContent =
              m365RefreshLabel || "Refresh License Catalog";
          }
        }
      };

      if (m365RefreshButton) {
        m365RefreshButton.addEventListener("click", () => {
          m365RefreshButton.disabled = true;
          m365RefreshButton.textContent = "Refreshing…";
          loadM365Status(true);
        });
      }

      renderM365Status(m365InitialStatus);
      if (
        m365InitialStatus &&
        m365InitialStatus.configured &&
        (!m365InitialStatus.sku_count || m365InitialStatus.stale)
      ) {
        loadM365Status(m365InitialStatus.stale);
      }

      const wireDatalist = (input, datalist, endpoint, initialItems = [], options = {}) => {
        if (!input || !datalist) {
          return { setStatic: () => {} };
        }
        const minLength =
          typeof options.minLength === "number" && options.minLength >= 0
            ? options.minLength
            : 2;
        const preload = Boolean(options.preload);
        const requestLimit =
          typeof options.limit === "number" && options.limit > 0 ? options.limit : 200;

        let staticItems = Array.from(
          new Set((initialItems || []).map((item) => (item || "").trim()).filter(Boolean))
        );

        const render = (dynamicItems = []) => {
          const seen = new Set();
          datalist.innerHTML = "";
          const addOption = (value) => {
            const normalized = (value || "").trim();
            if (!normalized || seen.has(normalized)) {
              return;
            }
            seen.add(normalized);
            const option = document.createElement("option");
            option.value = normalized;
            datalist.appendChild(option);
          };
          staticItems.forEach(addOption);
          (dynamicItems || []).forEach(addOption);
        };

        render();

        const fetchAndRender = async (query) => {
          try {
            const payload = await fetchJson(endpoint, query, requestLimit);
            render(payload.items || []);
          } catch (error) {
            console.error(error);
          }
        };

        let timer;
        input.addEventListener("input", () => {
          clearTimeout(timer);
          const value = input.value.trim();
          if (value.length < minLength) {
            render();
            return;
          }
          timer = setTimeout(async () => {
            fetchAndRender(value);
          }, 200);
        });

        if (preload) {
          input.addEventListener("focus", () => {
            fetchAndRender(input.value.trim());
          });
          fetchAndRender("");
        }

        return {
          setStatic(items) {
            staticItems = Array.from(
              new Set((items || []).map((item) => (item || "").trim()).filter(Boolean))
            );
            render();
          },
        };
      };

      const createManagerAutocomplete = (input, hidden, results, clearButton) => {
        if (!input || !hidden || !results) {
          return () => {};
        }

        const clearResults = () => {
          results.innerHTML = "";
          results.hidden = true;
        };

        let timer;
        input.addEventListener("input", () => {
          clearTimeout(timer);
          const value = input.value.trim();
          hidden.value = "";
          if (!value) {
            clearResults();
            return;
          }
          timer = setTimeout(async () => {
            try {
              const payload = await fetchJson("/api/managers", value);
              const items = payload.items || [];
              results.innerHTML = "";
              items.forEach((item) => {
                const div = document.createElement("div");
                div.className = "autocomplete-item";
                const pieces = [
                  item.displayName,
                  item.title,
                  item.mail,
                  item.sAMAccountName,
                ].filter(Boolean);
                div.textContent = pieces.join(" ").trim() || item.distinguishedName;
                div.dataset.dn = item.distinguishedName;
                div.dataset.display = div.textContent;
                div.addEventListener("mousedown", (event) => {
                  event.preventDefault();
                  hidden.value = div.dataset.dn;
                  input.value = div.dataset.display || div.dataset.dn;
                  clearResults();
                });
                results.appendChild(div);
              });
              results.hidden = results.children.length === 0;
            } catch (error) {
              console.error(error);
              clearResults();
            }
          }, 200);
        });
        input.addEventListener("blur", () => {
          setTimeout(clearResults, 150);
        });
        clearButton?.addEventListener("click", () => {
          input.value = "";
          hidden.value = "";
          clearResults();
        });

        return (label, dn) => {
          input.value = label || dn || "";
          hidden.value = dn || "";
        };
      };

      const formatAttributesTextarea = (attributes) => {
        if (!attributes) {
          return "";
        }
        return Object.entries(attributes)
          .map(([key, value]) => `${key}=${value}`)
          .join("\n");
      };

      const parseAttributesTextarea = (value) => {
        const result = {};
        const lines = (value || "").split(/\r?\n/);
        for (const line of lines) {
          const trimmed = line.trim();
          if (!trimmed || trimmed.startsWith("#")) {
            continue;
          }
          const index = trimmed.indexOf("=");
          if (index === -1) {
            throw new Error("Attributes must be key=value, one per line.");
          }
          const key = trimmed.slice(0, index).trim();
          const val = trimmed.slice(index + 1).trim();
          if (key) {
            result[key] = val;
          }
        }
        return result;
      };

      const createGroupPicker = (tagsEl, searchInput, resultsEl) => {
        const map = new Map();

        const render = () => {
          if (!tagsEl) {
            return;
          }
          tagsEl.innerHTML = "";
          map.forEach(({ value, label }) => {
            const tag = document.createElement("span");
            tag.className = "tag";
            const text = document.createElement("span");
            text.textContent = label;
            const remove = document.createElement("button");
            remove.type = "button";
            remove.className = "tag-remove";
            remove.innerHTML = "&times;";
            remove.setAttribute("aria-label", `Remove ${label}`);
            remove.addEventListener("click", () => {
              map.delete(value);
              render();
            });
            tag.appendChild(text);
            tag.appendChild(remove);
            tagsEl.appendChild(tag);
          });
          tagsEl.hidden = map.size === 0;
        };

        const add = (value, label, silent = false) => {
          const normalized = (value || "").trim();
          if (!normalized || map.has(normalized)) {
            return;
          }
          const friendly = label || normalized;
          map.set(normalized, {
            value: normalized,
            label: friendly,
          });
          if (!silent) {
            render();
          }
        };

        const set = (values) => {
          map.clear();
          (values || []).forEach((value) => add(value, undefined, true));
          render();
        };

        const get = () => Array.from(map.keys());

        if (searchInput && resultsEl) {
          const clearResults = () => {
            resultsEl.innerHTML = "";
            resultsEl.hidden = true;
          };

          let timer;
          searchInput.addEventListener("input", () => {
            clearTimeout(timer);
            const term = searchInput.value.trim();
            if (!term) {
              clearResults();
              return;
            }
            timer = setTimeout(async () => {
              try {
                const payload = await fetchJson("/api/groups", term);
                const items = payload.items || [];
                resultsEl.innerHTML = "";
                items.forEach((item) => {
                  const dn = item.distinguishedName;
                  if (!dn) {
                    return;
                  }
                  const div = document.createElement("div");
                  div.className = "autocomplete-item";
                  div.textContent = item.name || dn;
                  div.addEventListener("mousedown", (event) => {
                    event.preventDefault();
                    add(dn, item.name || dn);
                    render();
                    searchInput.value = "";
                    clearResults();
                  });
                  resultsEl.appendChild(div);
                });
                resultsEl.hidden = resultsEl.children.length === 0;
              } catch (error) {
                console.error(error);
                clearResults();
              }
            }, 200);
          });
          searchInput.addEventListener("keydown", (event) => {
            if (event.key === "Enter") {
              event.preventDefault();
            }
          });
          searchInput.addEventListener("blur", () => {
            window.setTimeout(clearResults, 150);
          });
        }

        return { add, set, get };
      };

      const roleTableBody = document.getElementById("role_table_body");
      const roleNewButton = document.getElementById("role_new_button");
      const roleForm = document.getElementById("role_form");
      const roleFormHeading = document.getElementById("role_form_heading");
      const roleOriginalNameInput = document.getElementById("role_original_name");
      const roleNameInput = document.getElementById("role_name");
      const roleTitleDatalist = document.getElementById("role-title-suggestions");
      const roleDescriptionInput = document.getElementById("role_description");
      const roleUserOuInput = document.getElementById("role_user_ou");
      const roleUserOuDatalist = document.getElementById("role-ou-suggestions");
      const roleManagerSearchInput = document.getElementById("role_manager_search");
      const roleManagerDnInput = document.getElementById("role_manager_dn");
      const roleManagerResults = document.getElementById("role_manager_results");
      const roleManagerClear = document.getElementById("role_manager_clear");
      const roleAttributesInput = document.getElementById("role_attributes");
      const roleGroupTags = document.getElementById("role_group_tags");
      const roleGroupSearchInput = document.getElementById("role_group_search");
      const roleGroupResults = document.getElementById("role_group_results");
      const roleMessage = document.getElementById("role_form_message");
      const roleResetButton = document.getElementById("role_reset_button");

      const getRoleTitleSeeds = () =>
        Array.from(
          new Set([
            ...(Array.isArray(initialJobTitles) ? initialJobTitles : []),
            ...state.roles.map((role) => role.name).filter(Boolean),
          ])
        );

      const setRoleMessage = (text, variant = "success") => {
        if (!roleMessage) {
          return;
        }
        if (!text) {
          roleMessage.hidden = true;
          roleMessage.textContent = "";
          roleMessage.className = "field";
          return;
        }
        roleMessage.hidden = false;
        roleMessage.textContent = text;
        roleMessage.className = `field flash ${variant}`;
      };

      const roleTitleSuggestions = wireDatalist(
        roleNameInput,
        roleTitleDatalist,
        "/api/job-titles",
        getRoleTitleSeeds(),
        { minLength: 1, preload: true, limit: 500 }
      );
      wireDatalist(roleUserOuInput, roleUserOuDatalist, "/api/ous");
      const setManagerField = createManagerAutocomplete(
        roleManagerSearchInput,
        roleManagerDnInput,
        roleManagerResults,
        roleManagerClear
      );
      const roleGroupPicker = createGroupPicker(roleGroupTags, roleGroupSearchInput, roleGroupResults);

      const resetRoleForm = () => {
        roleFormHeading.textContent = "Add Role";
        roleOriginalNameInput.value = "";
        roleNameInput.value = "";
        roleDescriptionInput.value = "";
        roleUserOuInput.value = "";
        setManagerField("", "");
        roleAttributesInput.value = "";
        roleGroupPicker.set([]);
        setRoleMessage("");
      };

      const upsertRoleLocal = (role, originalName) => {
        if (!role) {
          return;
        }
        const targetName = role.name;
        const existingIndex = state.roles.findIndex((item) => item.name === targetName);
        if (existingIndex >= 0) {
          state.roles.splice(existingIndex, 1, role);
        } else {
          if (originalName && originalName !== targetName) {
            const oldIndex = state.roles.findIndex((item) => item.name === originalName);
            if (oldIndex >= 0) {
              state.roles.splice(oldIndex, 1);
            }
          }
          state.roles.push(role);
        }
        state.roles.sort((a, b) => a.name.localeCompare(b.name));
        roleTitleSuggestions.setStatic(getRoleTitleSeeds());
      };

      const removeRoleLocal = (name) => {
        const index = state.roles.findIndex((item) => item.name === name);
        if (index >= 0) {
          state.roles.splice(index, 1);
        }
        roleTitleSuggestions.setStatic(getRoleTitleSeeds());
      };

      const renderRoleTable = () => {
        if (!roleTableBody) {
          return;
        }
        if (state.roles.length === 0) {
          roleTableBody.innerHTML = "<tr><td colspan='5'>No roles have been configured yet.</td></tr>";
          return;
        }
        roleTableBody.innerHTML = "";
        state.roles.forEach((role) => {
          const row = document.createElement("tr");
          row.dataset.roleName = role.name;

          const nameCell = document.createElement("td");
          nameCell.textContent = role.name;
          row.appendChild(nameCell);

          const managerCell = document.createElement("td");
          managerCell.textContent = role.default_manager_dn || "";
          row.appendChild(managerCell);

          const groupsCell = document.createElement("td");
          groupsCell.textContent = String(role.groups?.length || 0);
          row.appendChild(groupsCell);

          const notesCell = document.createElement("td");
          notesCell.textContent = role.description || "";
          row.appendChild(notesCell);

          const actionsCell = document.createElement("td");
          const editButton = document.createElement("button");
          editButton.type = "button";
          editButton.className = "button secondary role-edit";
          editButton.dataset.roleName = role.name;
          editButton.textContent = "Edit";
          actionsCell.appendChild(editButton);

          const deleteButton = document.createElement("button");
          deleteButton.type = "button";
          deleteButton.className = "button secondary role-delete";
          deleteButton.dataset.roleName = role.name;
          deleteButton.textContent = "Delete";
          deleteButton.style.marginLeft = "0.5rem";
          actionsCell.appendChild(deleteButton);

          row.appendChild(actionsCell);
          roleTableBody.appendChild(row);
        });
      };

      const loadRoleIntoForm = (role) => {
        roleFormHeading.textContent = `Edit Role: ${role.name}`;
        roleOriginalNameInput.value = role.name;
        roleNameInput.value = role.name;
        roleDescriptionInput.value = role.description || "";
        roleUserOuInput.value = role.user_ou || "";
        setManagerField(role.default_manager_dn, role.default_manager_dn);
        roleAttributesInput.value = formatAttributesTextarea(role.attributes);
        roleGroupPicker.set(role.groups || []);
        setRoleMessage("");
        roleNameInput.focus();
      };

      roleTableBody?.addEventListener("click", async (event) => {
        const editButton = event.target.closest(".role-edit");
        if (editButton) {
          const name = editButton.dataset.roleName;
          const role = state.roles.find((item) => item.name === name);
          if (role) {
            loadRoleIntoForm(role);
          }
          return;
        }
        const deleteButton = event.target.closest(".role-delete");
        if (deleteButton) {
          const name = deleteButton.dataset.roleName;
          if (!name) {
            return;
          }
          if (!confirm(`Delete role '${name}'?`)) {
            return;
          }
          try {
            const response = await fetch(`/api/roles/${encodeURIComponent(name)}`, {
              method: "DELETE",
              headers: { Accept: "application/json" },
            });
            if (!response.ok && response.status !== 204) {
              const payload = await response.json().catch(() => ({}));
              throw new Error(payload.error || "Unable to delete role.");
            }
            removeRoleLocal(name);
            renderRoleTable();
            if (roleOriginalNameInput.value === name) {
              resetRoleForm();
            }
          } catch (error) {
            console.error(error);
            alert(error.message || "Unable to delete role.");
          }
        }
      });

      roleForm?.addEventListener("submit", async (event) => {
        event.preventDefault();
        setRoleMessage("");
        try {
          const attributes = parseAttributesTextarea(roleAttributesInput.value);
          const payload = {
            original_name: roleOriginalNameInput.value || null,
            name: roleNameInput.value.trim(),
            description: roleDescriptionInput.value.trim() || null,
            user_ou: roleUserOuInput.value.trim() || null,
            default_manager_dn: roleManagerDnInput.value.trim() || null,
            attributes,
            groups: roleGroupPicker.get(),
          };
          if (!payload.name) {
            throw new Error("Role name is required.");
          }
          const response = await fetch("/api/roles", {
            method: "POST",
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json",
            },
            body: JSON.stringify(payload),
          });
          const data = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(data.error || "Unable to save role.");
          }
          const updatedRole = data.role;
          upsertRoleLocal(updatedRole, payload.original_name);
          renderRoleTable();
          loadRoleIntoForm(updatedRole);
          setRoleMessage("Role saved.", "success");
        } catch (error) {
          console.error(error);
          setRoleMessage(error.message || "Unable to save role.", "error");
        }
      });

      roleNewButton?.addEventListener("click", resetRoleForm);
      roleResetButton?.addEventListener("click", resetRoleForm);

      renderRoleTable();
    });
  </script>
{% endblock %}
